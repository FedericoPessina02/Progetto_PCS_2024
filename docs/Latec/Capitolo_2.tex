\chapter{Scelte implementative}

\section{Scelte computazionali per le principali funzioni}
Per quanto riguarda l'efficienza in termini di spazio l'utilizzo delle referenze per passare gli argomenti delle funzioni è fondamentale per evitare di generare, inutilmente, delle copie ad ogni chiamata di funzione. \newline
Invece i \textit{const} prima di passare gli argomenti sono stati utilizzati quando il dato passato non doveva venire modificato in quella funzione. \newline
E' stato necessario ordinare le fratture in ordine decrescente per lunghezza, e per tale scopo abbiamo incluso gli algoritmi di ordinamento \textit{Mergesort} e \textit{Bubblesort}. \newline
Nonostante il costo computazionale del Bubblesort sia $\mathcal{O}(n^2)$ che risulta essere maggiore del costo per implementare il Mergesort che invece è $\mathcal{O}(n \log n) $, per i dataset forniti impiega meno tempo. Questo a causa del basso costo fisso del Bubblesort, e di come funzionano i due algoritmi: il Mergesort (a differenza del Bubblesort) è basato sulle chiamate di funzioni ricorsive, ciascuna delle quali ha un impatto sulla velocità dell' algoritmo.


\section{Le classi utilizzate}
\textit{Fracture} - La prima classe che abbiamo introdotto è quella per memorizzare le fratture; abbiamo optato per salvare una frattura come istanza della classe, piuttosto che avere come istanza la lista di tutte le fratture, per semplificare l'accesso e la definizione dei metodi sulle istanze. \newline
\textit{TracesMesh} - Per invece esportare le informazioni riguardanti le tracce, abbiamo utilizzato l'approccio opposto memorizzando in una singola istanza della classe tutte le tracce calcolate, dal momento in cui non erano richiesti particolari conti. \newline
\textit{PolygonalMesh} - Nella seconda parte del progetto abbiamo invece costruito una mesh per ogni frattura, che contiene tutti i poligoni ottenuti tramite i tagli delle tracce. Questo approccio permette di suddividere il problema globale, dei tagli delle fratture, in diversi problemi locali indipendenti tra loro.


\section{Strutture dati}
I due principali tipi di contenitori impegiati sono stati i vettori della libreria standard, utili quando le loro dimensioni non erano note a priori, ed i vettori/matrici della libreria \textit{Eigen}, che hanno il vantaggio di avere implementati nativamente i metodi per svolgere le operazioni tra vettori e matrici, come ad esempio prodotti vettoriali e risoluzioni di problemi lineari. \newline
Abbiamo utilizzato in alcune funzioni la struttura map (ad esempio per associare ad una frattura tutte le tracce coinvolte).

\section{Scelta della tolleranza e altri dettagli}
Poichè è stato necessario effettuare diversi calcoli durante il progetto, spesso ci si è posto davanti il problema di dover stabilire quando due numeri fossero uguali, e poichè i conti sul calcolatore non sono esatti, abbiamo dovuto tenere in considerazione che le uguaglianze in senso stretto non hanno senso, e dunque abbiamo introdotto le uguaglianze a meno di una tolleranza.
Come valore per la tolleranza abbiamo scelto il valore $500$*$\epsilon$ con $ \epsilon =$ epsilon di macchina. \newline
Il valore è stato scelto euristicamente grande a sufficienza per evitare di classificare due punti diversi come lo stesso, e piccolo abbastanza per sfruttare il più possibile la precisione fornita dai dati iniziali.  Inoltre è stato inserito come variabile universale quindi facilmente modificabile\newline
\newline
\textbf{Altri dettagli:} \newline
\begin{itemize}
    \item Abbiamo inoltre dovuto stabilire se alcuni segmenti fossero degeneri (distanza tra gli estremi troppo piccola) e per farlo abbiamo considerato anzichè la norma dei vettori la norma al quadrato evitando così di chiamare la funzione \textit{norm} che include la radice quadrata, che è una funzione computazionalmente costosa.
    %\item Nella risoluzione dei sistemi lineari, utilizzata nei calcoli relativi ad intersezioni tra piani/rette, i sistemi sono stati risolti 5con le fattorizzazioni PA-LU o QR rispettivamente per matrici dei coefficienti quadrate, con costo computazionale $\mathcal{O}(\frac{1}{3}n^3)$ , e rettangolari, con costo $\mathcal{O}(\frac{2}{3}n^3) $
    \item In alcune funzioni avremmo potuto utilizzare il comando inline per velocizzare il codice: \textit{addPoint} e \textit{addEdge} sono due metodi per i quali, il comando inline, sarebbe stato opportuno in quanto entrambi sono brevi e vengono richiamati di sovente. \newline Inline evita che tali metodi vengano richiamati ogni volta, alleggerendo così lo stack frame.
    \item Nella seconda parte del progetto inizialmente avevamo individuato un altro algoritmo per risolvere il problema dei tagli delle fratture, ma procedendo nel suo sviluppo ci siamo resi conto che era molto dispendioso, in quanto si basava sul calcolo di molti prodotti vettoriali e di molti sistemi lineari, e lo abbiamo dunque accantonato per prendere in considerazione un'altra strada (che è risultata essere piuttosto efficiente).
 
\end{itemize}
